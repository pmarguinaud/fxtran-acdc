MODULE REGLATLON_FIELD_MIX

!$ACDC methods 


USE PARKIND1  ,ONLY : JPIM     ,JPRB
USE YOMLUN   , ONLY : NULOUT
USE YOMHOOK   ,ONLY : LHOOK,   DR_HOOK, JPHOOK
IMPLICIT NONE
SAVE

!#include "abor1.intfb.h

! Define a regular lat-lon field. 
! Assume that:
!       latitude and longitude spacing is regular
!       That the grid spans the entire longitude circle
!
!     Hans Hersbach  9/12/2010
!     M. Fisher   7-March-2012 Use DEALLOCATE_IF_ASSOCIATED + remove semicolons


TYPE REGLATLON_FIELD
  INTEGER(KIND=JPIM)       :: NLAT               ! # of latitudes   ; >=1
  INTEGER(KIND=JPIM)       :: NLON               ! # of longitudes  ; >=1
  REAL(KIND=JPRB)          :: DLAT               ! Latitude  increment (degrees), can be positve/negative
  REAL(KIND=JPRB)          :: DLON               ! Longitude increment (degrees), is assumed to be positve
  REAL(KIND=JPRB) ,POINTER :: PFLD(:,:)=>NULL()  ! Field contents as (lat,lon)
  REAL(KIND=JPRB) ,POINTER :: PLAT(:)  =>NULL()  ! List of NLAT  Latitudes (degrees)
  REAL(KIND=JPRB) ,POINTER :: PSIN(:)  =>NULL()  ! List of NLAT  SIN(Latitudes)
  REAL(KIND=JPRB) ,POINTER :: PLON(:)  =>NULL()  ! List of NLON Longitudes (degrees)
CONTAINS
PROCEDURE :: ACDC_COPY => ACDC_COPY_REGLATLON_FIELD
PROCEDURE :: ACDC_CRC64 => ACDC_CRC64_REGLATLON_FIELD
PROCEDURE :: ACDC_HOST => ACDC_HOST_REGLATLON_FIELD
PROCEDURE :: ACDC_LOAD => ACDC_LOAD_REGLATLON_FIELD
PROCEDURE :: ACDC_SAVE => ACDC_SAVE_REGLATLON_FIELD
PROCEDURE :: ACDC_SIZE => ACDC_SIZE_REGLATLON_FIELD
PROCEDURE :: ACDC_WIPE => ACDC_WIPE_REGLATLON_FIELD
END TYPE REGLATLON_FIELD

INTERFACE

MODULE SUBROUTINE ACDC_COPY_REGLATLON_FIELD (SELF, LDCREATED, LDFIELDAPI)

IMPLICIT NONE
CLASS (REGLATLON_FIELD), INTENT (IN), TARGET :: SELF
LOGICAL, OPTIONAL, INTENT (IN) :: LDCREATED, LDFIELDAPI
END SUBROUTINE

MODULE SUBROUTINE ACDC_CRC64_REGLATLON_FIELD (SELF, KLUN, CDPATH)
USE FXTRAN_ACDC_CRC64_INTRINSIC_MOD, ONLY : FCRC64 => FXTRAN_ACDC_CRC64
IMPLICIT NONE
CLASS (REGLATLON_FIELD), TARGET :: SELF
INTEGER, INTENT (IN) :: KLUN
CHARACTER(LEN=*), INTENT (IN) :: CDPATH
END SUBROUTINE

MODULE SUBROUTINE ACDC_HOST_REGLATLON_FIELD (SELF)

IMPLICIT NONE
CLASS (REGLATLON_FIELD), TARGET :: SELF
END SUBROUTINE

MODULE SUBROUTINE ACDC_LOAD_REGLATLON_FIELD (SELF, KLUN)
USE PARKIND1, ONLY : JPRD
IMPLICIT NONE
CLASS (REGLATLON_FIELD), INTENT (OUT), TARGET :: SELF
INTEGER, INTENT (IN) :: KLUN
END SUBROUTINE

MODULE SUBROUTINE ACDC_SAVE_REGLATLON_FIELD (SELF, KLUN)

IMPLICIT NONE
CLASS (REGLATLON_FIELD), INTENT (IN), TARGET :: SELF
INTEGER, INTENT (IN) :: KLUN
END SUBROUTINE

MODULE FUNCTION ACDC_SIZE_REGLATLON_FIELD (SELF, CDPATH, LDPRINT) RESULT (KSIZE)

IMPLICIT NONE
CLASS (REGLATLON_FIELD),     INTENT (IN), TARGET :: SELF
CHARACTER(LEN=*), INTENT (IN), OPTIONAL :: CDPATH
LOGICAL,          INTENT (IN), OPTIONAL :: LDPRINT
INTEGER*8 :: KSIZE
END FUNCTION

MODULE SUBROUTINE ACDC_WIPE_REGLATLON_FIELD (SELF, LDDELETED, LDFIELDAPI)

IMPLICIT NONE
CLASS (REGLATLON_FIELD), INTENT (IN), TARGET :: SELF
LOGICAL, OPTIONAL, INTENT (IN) :: LDDELETED, LDFIELDAPI
END SUBROUTINE


END INTERFACE

CONTAINS

! - -----------------------------------------------------------------------------------------------

SUBROUTINE CREATE_REGLATLON_FIELD(YDFLL,KNLAT,KNLON,PLAT1,PLATN,PLON1,LDEW,CDNAME)

  USE DEALLOCATE_IF_ASSOCIATED_MOD, ONLY : DEALLOCATE_IF_ASSOCIATED

  IMPLICIT NONE

  TYPE(REGLATLON_FIELD)      ,INTENT(OUT) :: YDFLL
  INTEGER(KIND=JPIM),OPTIONAL,INTENT(IN ) :: KNLAT,KNLON
  REAL(KIND=JPRB)   ,OPTIONAL,INTENT(IN ) :: PLAT1,PLATN,PLON1
  LOGICAL           ,OPTIONAL,INTENT(IN ) :: LDEW
  CHARACTER(LEN=*)  ,OPTIONAL,INTENT(IN ) :: CDNAME

!-Local variables
  INTEGER(KIND=JPIM) :: IKLAT,ILAT,IKLON,ILON,I
  REAL(KIND=JPRB)    :: ZLL
  REAL(KIND=JPHOOK) :: ZHOOK_HANDLE
  IF (LHOOK) CALL DR_HOOK('REGLATLON_FIELD_MIX:CREATE_REGLATLON_FIELD',0,ZHOOK_HANDLE)

!-Set dims, subject to some defaults
  IF (PRESENT(KNLAT)) THEN
    IKLAT=KNLAT
  ELSE
    IKLAT=1
  ENDIF
  YDFLL%NLAT =IKLAT

  IKLON=1
  IF (PRESENT(KNLON)) THEN
    IKLON=KNLON
  ELSE
    IKLON=1
  ENDIF
  YDFLL%NLON =IKLON 

!-Some QC
  IF(KNLAT<1) CALL ABORT()
  IF(KNLON<1) CALL ABORT()

!-Allocate arrays
  CALL DEALLOCATE_IF_ASSOCIATED(YDFLL%PFLD)
  ALLOCATE(YDFLL%PFLD(IKLAT,IKLON))

  CALL DEALLOCATE_IF_ASSOCIATED(YDFLL%PLAT)
  ALLOCATE(YDFLL%PLAT(IKLAT))
  CALL DEALLOCATE_IF_ASSOCIATED(YDFLL%PSIN)
  ALLOCATE(YDFLL%PSIN(IKLAT))
  CALL DEALLOCATE_IF_ASSOCIATED(YDFLL%PLON)
  ALLOCATE(YDFLL%PLON(     IKLON))

!-Fill in latitudes. By default assume that grid runs from 90S to 90N
  IF(PRESENT(PLATN)) THEN
    YDFLL%PLAT(IKLAT)=PLATN
  ELSE
    YDFLL%PLAT(IKLAT)= 90.0_JPRB
  ENDIF


  IF(PRESENT(PLAT1)) THEN
    YDFLL%PLAT(   1)=PLAT1
  ELSE
    YDFLL%PLAT(   1)=-90.0_JPRB
  ENDIF

  ILAT=MAX(IKLAT-1,1)
  YDFLL%DLAT=(YDFLL%PLAT(IKLAT)-YDFLL%PLAT(1))/REAL(ILAT)
  DO ILAT=1,IKLAT
     YDFLL%PLAT(ILAT)=YDFLL%PLAT(1)+(ILAT-1)*YDFLL%DLAT
     YDFLL%PSIN(ILAT)=SIN(ASIN(1._JPRB)*YDFLL%PLAT(ILAT)/90._JPRB)
  ENDDO

!-Fill in longitudes
!-By default assume that grid runs from West to East

  YDFLL%DLON=360._JPRB/KNLON 
     IF (PRESENT(LDEW)) THEN 
        IF(LDEW) YDFLL%DLON = -YDFLL%DLON
     ENDIF
  YDFLL%PLON(   1)=0.0_JPRB 
     IF(PRESENT(PLON1)) YDFLL%PLON(   1)=XMOD(PLON1)

  ZLL=(IKLON-1._JPRB)/IKLON*360.0_JPRB
  YDFLL%PLON(IKLON)=ZLL     
  DO ILON=2,IKLON
     YDFLL%PLON(ILON)=XMOD(YDFLL%PLON(1)+(ILON-1)*YDFLL%DLON)
  ENDDO

  IF (PRESENT(CDNAME)) THEN
     WRITE(NULOUT,'(54A)')("-",I=1,54)
     WRITE(NULOUT,'(2A)')"CREATE_REGLATLON_FIELD FOR: ",TRIM(CDNAME)
     WRITE(NULOUT,'(12X,A6,3A12  )')"NUMBER","FIRST","LAST","INCREMENT"
     WRITE(NULOUT,'(A12,I6,3F12.7)')"LATITUDE :",YDFLL%NLAT,YDFLL%PLAT(1),YDFLL%PLAT(YDFLL%NLAT),YDFLL%DLAT
     WRITE(NULOUT,'(A12,I6,3F12.7)')"LONGITUDE:",YDFLL%NLON,YDFLL%PLON(1),YDFLL%PLON(YDFLL%NLON),YDFLL%DLON
     WRITE(NULOUT,'(54A)')("-",I=1,54)
  ENDIF

  IF (LHOOK) CALL DR_HOOK('REGLATLON_FIELD_MIX:CREATE_REGLATLON_FIELD',1,ZHOOK_HANDLE)

END SUBROUTINE CREATE_REGLATLON_FIELD

! - -----------------------------------------------------------------------------------------------

SUBROUTINE INTPOL_REGLATLON(PINTVAL,YDFLL,PLAT,PLON,PSIN)

  IMPLICIT NONE

  REAL (KIND=JPRB)         ,INTENT(OUT) :: PINTVAL
  TYPE (REGLATLON_FIELD)   ,INTENT(IN ) :: YDFLL
  REAL (KIND=JPRB)         ,INTENT(IN ) :: PLON
  REAL (KIND=JPRB),OPTIONAL,INTENT(IN ) :: PSIN,PLAT
  
!-Local variables
  INTEGER(KIND=JPIM) :: ILON(2), ILAT(2), I,J
  REAL   (KIND=JPRB) :: ZXD , ZLAT
  REAL   (KIND=JPRB) :: ZDLON(2), ZDLAT(2),ZDX1,ZDX12
  REAL(KIND=JPHOOK) :: ZHOOK_HANDLE

  IF (LHOOK) CALL DR_HOOK('REGLATLON_FIELD_MIX:INTPOL_REGLATLON',0,ZHOOK_HANDLE)

  IF (.NOT.PRESENT(PLAT) .AND. .NOT.PRESENT(PSIN)) &
  &  CALL ABOR1("INTPOL_REGLATLON: EITHER PLAT OR PLON SHOULD BE ARGUMENT")

!-Latitude
  IF (PRESENT(PSIN)) THEN
     ZLAT=90._JPRB*ASIN(PSIN)/ASIN(1._JPRB)
  ELSE
     ZLAT=PLAT
  ENDIF
  ZXD=1._JPRB + (ZLAT-YDFLL%PLAT(1))/YDFLL%DLAT

  ILAT(1)=INT(ZXD)
  ILAT(2)=ILAT(1)+1
  ILAT(1)=MAX(1,MIN(ILAT(1),YDFLL%NLAT))
  ILAT(2)=MAX(1,MIN(ILAT(2),YDFLL%NLAT))

  IF (PRESENT(PSIN)) THEN
     ZDX1 =YDFLL%PSIN(ILAT(2))-PSIN
     ZDX12=YDFLL%PSIN(ILAT(2))-YDFLL%PSIN(ILAT(1))
  ELSE
     ZDX1 =YDFLL%PLAT(ILAT(2))-PLAT
     ZDX12=YDFLL%PLAT(ILAT(2))-YDFLL%PLAT(ILAT(1))
  ENDIF

  IF(ZDX12/=0.0_JPRB) THEN
     ZDLAT(1)=XCAP(ZDX1/ZDX12)
  ELSE
     ZDLAT(1)=1._JPRB
  ENDIF
  ZDLAT(2)=1._JPRB-ZDLAT(1)

!-Longitude
  IF (YDFLL%DLON<0._JPRB) THEN
    ZXD=-ZXD
  ELSE
    ZXD=PLON-YDFLL%PLON(1)
  ENDIF

  ZXD=1._JPRB+XMOD(ZXD)/ABS(YDFLL%DLON)

  ILON(1)=INT(ZXD)
  ILON(2)=ILON(1)+1
  ILON(1)=MOD(ILON(1)-1,YDFLL%NLON) + 1
  ILON(2)=MOD(ILON(2)-1,YDFLL%NLON) + 1
  ZDLON(2)=XCAP(ZXD-ILON(1))
  ZDLON(1)=1._JPRB-ZDLON(2)

!-Bi-linear Interpolation
  PINTVAL=0._JPRB
  DO I=1,2 
     DO J=1,2
        PINTVAL=PINTVAL+ZDLAT(I)*ZDLON(J)*YDFLL%PFLD(ILAT(I),ILON(J))
     ENDDO
  ENDDO

  IF (LHOOK) CALL DR_HOOK('REGLATLON_FIELD_MIX:INTPOL_REGLATLON',1,ZHOOK_HANDLE)

END SUBROUTINE INTPOL_REGLATLON

! - -----------------------------------------------------------------------------------------------

SUBROUTINE STATS_REGLATLON(CDTEXT,YDFLL)
! Print some global statistics  

  IMPLICIT NONE

  TYPE (REGLATLON_FIELD),INTENT(IN ) :: YDFLL
  CHARACTER(LEN=*)      ,INTENT(IN ) :: CDTEXT

  REAL (KIND=JPRB) :: ZAVE
  REAL(KIND=JPHOOK) :: ZHOOK_HANDLE
  IF (LHOOK) CALL DR_HOOK('REGLATLON_FIELD_MIX:STATS_REGLATLON',0,ZHOOK_HANDLE)

  ZAVE=SUM(YDFLL%PFLD)/(YDFLL%NLAT*YDFLL%NLON)
  WRITE(NULOUT,*)TRIM(CDTEXT),", UNWEIGHTED AVERAGE: ",ZAVE
  IF (LHOOK) CALL DR_HOOK('REGLATLON_FIELD_MIX:STATS_REGLATLON',1,ZHOOK_HANDLE)

END SUBROUTINE STATS_REGLATLON

! - -----------------------------------------------------------------------------------------------

FUNCTION XCAP(PX)
  IMPLICIT NONE
  REAL (KIND=JPRB)            :: XCAP 
  REAL (KIND=JPRB),INTENT(IN) :: PX 
  XCAP=MAX(0._JPRB,MIN(PX,1._JPRB))
END FUNCTION XCAP

FUNCTION XMOD(PX)
  IMPLICIT NONE
  REAL (KIND=JPRB)            :: XMOD
  REAL (KIND=JPRB),INTENT(IN) :: PX 
  XMOD=MOD(3600._JPRB+PX,360._JPRB)
END FUNCTION XMOD

END MODULE REGLATLON_FIELD_MIX
