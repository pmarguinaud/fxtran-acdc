#!/usr/bin/env perl 

=head1 NAME

fxtran-ar

=head1 DESCRIPTION

C<fxtran-ar> is a wrapper around the traditional C<ar> utility. It is
supposed to behave similarly to C<ar> and accept the same options.

For now C<fxtran-> accept only the following commands:

=over 4

=item q

=item qc

=back

These two command strings are used by C<cmake> to create static
libraries.

The purpose of C<fxtran-ar> is to manage situations where objects
to be aggregated in a static library may actually be static libraries
themselves.

For instance, in the following command:

  $ fxtran-ar q lib.a a.o b.o ...

C<a.o> may be a static library:

  $ ar tv a.o 
  rw-r--r-- 0/0   1784 Jan  1 01:00 1970 O_a.o
  rw-r--r-- 0/0   1784 Jan  1 01:00 1970 O_b.o

In this case, C<fxtran-ar> will extract these objects, and build C<lib.a>
using them:

  $ ar rv a.o
  $ ar crv liba.o O_a.o O_b.o b.o ...

=head1 COPYRIGHT

Meteo-France 2025

=head1 AUTHOR

philippe.marguinaud@meteo.fr

=head1 SEE ALSO

C<ar>, C<fxtran-f90>

=cut

use warnings;

use FindBin qw ($Bin);
use lib "$Bin/../lib";

use Fxtran::Common;

use Getopt::Long;
use FileHandle;
use Data::Dumper;
use File::Temp;
use File::Basename;
use File::Spec;
use File::Copy;
use File::Path;
use File::Type;
use Cwd;

use strict;

my $AR = '/usr/bin/ar';

sub sysAR
{
  my @cmd = ($AR, @_);
  if ($cmd[1] eq 't')
    {
      my @obj = split (m/\n/o, `@cmd`);
      goto ERROR if ($?);
      return @obj;
    }
  else
    {
      system (@cmd)
        and goto ERROR;
    }

  return;

ERROR:
  die ("Command `@cmd' failed");
}

my ($mod, $ar, @obj) = @ARGV;

die unless ($mod && $ar);

die ("Archive command `$mod' is not supported\n")
  if (($mod ne 'q') && ($mod ne 'qc'));

my $ft = 'File::Type'->new ();

my @o;

my $dir = 'File::Temp'->newdir (CLEANUP => 1);
my $cwd = &cwd ();

for my $obj (@obj)
  {
    my $type = $ft->checktype_filename ($obj);

    if ($type eq 'application/x-executable-file')
      {
        push @o, $obj;
      }
    elsif ($type eq 'application/x-ar')
      {
        $obj = 'File::Spec'->rel2abs ($obj);

        chdir ($dir);

        push @o, map { 'File::Spec'->rel2abs ($_) } &sysAR ('t', $obj);

        &sysAR ('x', $obj);

        chdir ($cwd);
      }
    else   
      {
        die ("Unexpected type `$type' for object `$obj'");
      }
  }

&sysAR ($mod, $ar, @o);


