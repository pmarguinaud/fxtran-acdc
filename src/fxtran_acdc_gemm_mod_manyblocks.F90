MODULE FXTRAN_ACDC_GEMM_MOD_MANYBLOCKS

!
! Copyright 2025 Meteo-France
! All rights reserved
! philippe.marguinaud@meteo.fr
!

PRIVATE
PUBLIC :: FXTRAN_ACDC_GEMM_MANYBLOCKS

CONTAINS

SUBROUTINE FXTRAN_ACDC_GEMM_MANYBLOCKS &
&(KIDIA, KFDIA, TRANSA, TRANSB, M, N, K, ALPHA, A, LDA, B, LDB, BETA, C, LDC, LDDONE, &
& LDACC, KGPBLKS, YDOFFSET)

#ifdef USE_OPENACC
#if defined(_OPENACC) && (__NVCOMPILER==1)
USE CUBLAS_V2
USE CUDAFOR
#endif

USE FXTRAN_ACDC_STACK_MOD
USE FXTRAN_ACDC_ABORT_MOD

INTEGER                  :: KIDIA
INTEGER                  :: KFDIA
CHARACTER*1              :: TRANSA       ! 'N'
CHARACTER*1              :: TRANSB       ! 'T'
INTEGER                  :: M            ! KPROMA
INTEGER                  :: N            ! KLEVOUT-1
INTEGER                  :: K            ! KLEVIN
REAL*8                   :: ALPHA        ! 1.0_JPRD
REAL*8                   :: A (:, :, :)  ! ZIN   (KPROMA, KLEVIN, KGPBLKS)
INTEGER                  :: LDA          ! KPROMA
REAL*8                   :: B (:, :)     ! PINTE (KLEVOUT, KLEVIN)
INTEGER                  :: LDB          ! KLEVOUT
REAL*8                   :: BETA         ! 0.0_JPRD
REAL*8                   :: C (:, :, :)  ! ZOUT  (KPROMA, KLEVOUT, KGPBLKS)
INTEGER                  :: LDC          ! KPROMA
LOGICAL                  :: LDDONE
LOGICAL                  :: LDACC
INTEGER                  :: KGPBLKS
TYPE (FXTRAN_ACDC_STACK), OPTIONAL :: YDOFFSET

#ifdef _CUDA
TYPE (CUBLASHANDLE), SAVE :: YLCBH
LOGICAL, SAVE :: LLCBH_INITIALIZED = .FALSE.
INTEGER (KIND=CUDA_STREAM_KIND), PARAMETER :: STREAM = 0
#endif

INTEGER :: STRIDEA
INTEGER :: STRIDEB
INTEGER :: STRIDEC
INTEGER :: BATCHCOUNT

INTEGER :: JROF, JBLK, JK, JN

CHARACTER*1, SAVE :: CLENV = ''
LOGICAL, SAVE :: LLSIMPLE_DGEMM = .FALSE.

IF (CLENV == '') THEN
  CALL GETENV ('FXTRAN_ACDC_SIMPLE_DGEMM', CLENV)
  LLSIMPLE_DGEMM = CLENV (1:1) == '1' 
  CLENV = '0'
ENDIF


IF (TRANSA /= 'N') CALL FXTRAN_ACDC_ABORT ('FXTRAN_ACDC_GEMM')
IF (TRANSB /= 'T') CALL FXTRAN_ACDC_ABORT ('FXTRAN_ACDC_GEMM')
IF (ALPHA  /= 1._8) CALL FXTRAN_ACDC_ABORT ('FXTRAN_ACDC_GEMM')
IF (BETA   /= 0._8) CALL FXTRAN_ACDC_ABORT ('FXTRAN_ACDC_GEMM')
IF (KGPBLKS /= SIZE (A, 3)) CALL FXTRAN_ACDC_ABORT ('FXTRAN_ACDC_GEMM')
IF (KGPBLKS /= SIZE (C, 3)) CALL FXTRAN_ACDC_ABORT ('FXTRAN_ACDC_GEMM')
IF (LDA /= SIZE (A, 1)) CALL FXTRAN_ACDC_ABORT ('FXTRAN_ACDC_GEMM')
IF (LDC /= SIZE (C, 1)) CALL FXTRAN_ACDC_ABORT ('FXTRAN_ACDC_GEMM')
IF (LDB /= SIZE (B, 1)) CALL FXTRAN_ACDC_ABORT ('FXTRAN_ACDC_GEMM')

CALL CHECKCONTIGUOUS2 (A (:,:,1))
CALL CHECKCONTIGUOUS2 (B)
CALL CHECKCONTIGUOUS2 (C (:,:,1))

STRIDEA    = STRIDE3 (A)
STRIDEB    = 0
STRIDEC    = STRIDE3 (C)
BATCHCOUNT = KGPBLKS


IF (LLSIMPLE_DGEMM) THEN
!$ACC PARALLEL LOOP GANG &
!$ACC&IF (LDACC) &
!$ACC&PRESENT (A, B, C) &
!$ACC&PRIVATE (JBLK) &
!$ACC&VECTOR_LENGTH (LDA) 

  DO JBLK = 1, KGPBLKS
!$ACC LOOP VECTOR &
!$ACC&PRIVATE (JK, JN, JROF) 

    DO JROF = KIDIA, MERGE (M, KFDIA, JBLK < KGPBLKS)
      C (JROF,:, JBLK) = 0._8
      DO JK = 1, K
        DO JN = 1, N
          C (JROF, JN, JBLK) = C (JROF, JN, JBLK) + B (JN, JK) * A (JROF, JK, JBLK)
        ENDDO
      ENDDO
    ENDDO

  ENDDO

ELSE

  IF (LDACC) THEN

#ifdef _CUDA
IF (.NOT. LLCBH_INITIALIZED) THEN
  CALL CHECKCUBLAS (CUBLASCREATE (YLCBH))
  LLCBH_INITIALIZED = .TRUE.
ENDIF

!$ACC DATA PRESENT (A, B, C)
!$ACC HOST_DATA USE_DEVICE (A, B, C)
    CALL CHECKCUBLAS (&
      & CUBLASDGEMMSTRIDEDBATCHED_V2 (YLCBH, CUBLAS_OP_N, CUBLAS_OP_T, M, N, K, &
      &                        ALPHA, A (1, 1, 1), LDA, STRIDEA, &
      &                               B (1, 1),    LDB, STRIDEB, &
      &                        BETA,  C (1, 1, 1), LDC, STRIDEC, &
      &                               BATCHCOUNT))
!$ACC END HOST_DATA
!$ACC END DATA

    CALL CHECKCUDA (CUDASTREAMSYNCHRONIZE (STREAM))
    CALL CHECKCUDA (CUDADEVICESYNCHRONIZE ())
#else
    CALL FXTRAN_ACDC_ABORT ('FXTRAN_ACDC_GEMM')
#endif

  ELSE

    DO JBLK = 1, KGPBLKS
      CALL DGEMM ('N','T', M, N, K, ALPHA, A (1, 1, JBLK), LDA, B (1, 1), LDB, BETA, C (1, 1, JBLK), LDC)
    ENDDO

  ENDIF

ENDIF

LDDONE = .TRUE.

#endif

#ifdef USE_OPENMP
!#ifdef __HIP_PLATFORM_AMD__   !!compilation de hip avec amdflang a priori
USE HIPFORT
USE HIPFORT_ROCBLAS
USE ISO_C_BINDING
!#endif

USE FXTRAN_ACDC_STACK_MOD
USE FXTRAN_ACDC_ABORT_MOD

INTEGER                  :: KIDIA
INTEGER                  :: KFDIA
CHARACTER*1              :: TRANSA       ! 'N'
CHARACTER*1              :: TRANSB       ! 'T'
INTEGER                  :: M            ! KPROMA
INTEGER                  :: N            ! KLEVOUT-1
INTEGER                  :: K            ! KLEVIN
REAL*8                   :: ALPHA        ! 1.0_JPRD
REAL*8                   :: A (:, :, :)  ! ZIN   (KPROMA, KLEVIN, KGPBLKS)
INTEGER                  :: LDA          ! KPROMA
REAL*8                   :: B (:, :)     ! PINTE (KLEVOUT, KLEVIN)
INTEGER                  :: LDB          ! KLEVOUT
REAL*8                   :: BETA         ! 0.0_JPRD
REAL*8                   :: C (:, :, :)  ! ZOUT  (KPROMA, KLEVOUT, KGPBLKS)
INTEGER                  :: LDC          ! KPROMA
LOGICAL                  :: LDDONE
LOGICAL                  :: LDACC
INTEGER                  :: KGPBLKS
TYPE (FXTRAN_ACDC_STACK), OPTIONAL :: YDOFFSET

TYPE(C_PTR), SAVE :: YLCBH
LOGICAL, SAVE :: LLCBH_INITIALIZED = .FALSE.
TYPE(C_PTR), SAVE :: STREAM 

INTEGER(c_int64_t) :: STRIDEA
INTEGER(c_int64_t) :: STRIDEB
INTEGER(c_int64_t) :: STRIDEC
INTEGER :: BATCHCOUNT

INTEGER :: JROF, JBLK, JK, JN

CHARACTER*1, SAVE :: CLENV = ''
LOGICAL, SAVE :: LLSIMPLE_DGEMM = .FALSE.

IF (CLENV == '') THEN
  CALL GETENV ('FXTRAN_ACDC_SIMPLE_DGEMM', CLENV)
  LLSIMPLE_DGEMM = CLENV (1:1) == '1' 
  CLENV = '0'
ENDIF


IF (TRANSA /= 'N') CALL FXTRAN_ACDC_ABORT ('FXTRAN_ACDC_GEMM')
IF (TRANSB /= 'T') CALL FXTRAN_ACDC_ABORT ('FXTRAN_ACDC_GEMM')
IF (ALPHA  /= 1._8) CALL FXTRAN_ACDC_ABORT ('FXTRAN_ACDC_GEMM')
IF (BETA   /= 0._8) CALL FXTRAN_ACDC_ABORT ('FXTRAN_ACDC_GEMM')
IF (KGPBLKS /= SIZE (A, 3)) CALL FXTRAN_ACDC_ABORT ('FXTRAN_ACDC_GEMM')
IF (KGPBLKS /= SIZE (C, 3)) CALL FXTRAN_ACDC_ABORT ('FXTRAN_ACDC_GEMM')
IF (LDA /= SIZE (A, 1)) CALL FXTRAN_ACDC_ABORT ('FXTRAN_ACDC_GEMM')
IF (LDC /= SIZE (C, 1)) CALL FXTRAN_ACDC_ABORT ('FXTRAN_ACDC_GEMM')
IF (LDB /= SIZE (B, 1)) CALL FXTRAN_ACDC_ABORT ('FXTRAN_ACDC_GEMM')

CALL CHECKCONTIGUOUS2 (A (:,:,1))
CALL CHECKCONTIGUOUS2 (B)
CALL CHECKCONTIGUOUS2 (C (:,:,1))

STRIDEA    = STRIDE3 (A)
STRIDEB    = 0
STRIDEC    = STRIDE3 (C)
BATCHCOUNT = KGPBLKS

IF (LLSIMPLE_DGEMM) THEN

!$OMP TARGET DATA MAP(PRESENT:A(1:LDA,1:K,1:KGPBLKS), B(1:LDB,1:K), C(1:LDC,1:N,1:KGPBLKS)) IF(LDACC)
!$OMP TARGET TEAMS DISTRIBUTE PRIVATE(JBLK) THREAD_LIMIT(LDA) IF(LDACC)

  DO JBLK = 1, KGPBLKS
!$OMP PARALLEL DO SIMD PRIVATE(JK,JN,JROF) IF(LDACC)

    DO JROF = KIDIA, MERGE (M, KFDIA, JBLK < KGPBLKS)
      C (JROF,:, JBLK) = 0._8
      DO JK = 1, K
        DO JN = 1, N
          C (JROF, JN, JBLK) = C (JROF, JN, JBLK) + B (JN, JK) * A (JROF, JK, JBLK)
        ENDDO
      ENDDO
    ENDDO

  ENDDO
!$OMP END TARGET DATA

ELSE

  IF (LDACC) THEN

!#ifdef __HIP_PLATFORM_AMD__   !!compilation de hip avec amdflang a priori
#ifndef UNDEF
IF (.NOT. LLCBH_INITIALIZED) THEN
  CALL CHECKROCBLAS (ROCBLAS_CREATE_HANDLE (YLCBH))
  CALL CHECKROCBLAS(ROCBLAS_GET_STREAM(YLCBH,STREAM))
  LLCBH_INITIALIZED = .TRUE.
ENDIF

!$OMP TARGET DATA MAP(PRESENT:A(1:LDA,1:K,1:KGPBLKS), B(1:LDB,1:K), C(1:LDC,1:N,1:KGPBLKS))
!$OMP TARGET DATA USE_DEVICE_ADDR (A, B, C)
    CALL CHECKROCBLAS (&
      & ROCBLAS_DGEMM_STRIDED_BATCHED (YLCBH, ROCBLAS_OPERATION_NONE, ROCBLAS_OPERATION_TRANSPOSE, M, N, K, &
      &                        ALPHA, A (1, 1, 1), LDA, STRIDEA, &
      &                               B (1, 1),    LDB, STRIDEB, &
      &                        BETA,  C (1, 1, 1), LDC, STRIDEC, &
      &                               BATCHCOUNT))
!$OMP END TARGET DATA 
!$OMP END TARGET DATA

    CALL CHECKHIP (HIPSTREAMSYNCHRONIZE (STREAM))

#else
    CALL FXTRAN_ACDC_ABORT ('FXTRAN_ACDC_GEMM')
#endif

  ELSE

    DO JBLK = 1, KGPBLKS
      CALL DGEMM ('N','T', M, N, K, ALPHA, A (1, 1, JBLK), LDA, B (1, 1), LDB, BETA, C (1, 1, JBLK), LDC)
    ENDDO

  ENDIF

ENDIF

LDDONE = .TRUE.



#endif

END SUBROUTINE FXTRAN_ACDC_GEMM_MANYBLOCKS

SUBROUTINE CHECKCONTIGUOUS2 (P)

USE FXTRAN_ACDC_ABORT_MOD

REAL*8 :: P (:, :)
IF (LOC (P (1, 2)) - LOC (P (1, 1)) /= SIZE (P, 1) * 8) CALL FXTRAN_ACDC_ABORT ('FXTRAN_ACDC_GEMM')
END SUBROUTINE

INTEGER FUNCTION STRIDE3 (P)
REAL*8 :: P (:,:,:)
STRIDE3 = (LOC (P (1, 1, 2)) - LOC (P (1, 1, 1))) / 8
END FUNCTION

#ifdef _CUDA
SUBROUTINE CHECKCUBLAS (STATUS)

USE CUBLAS_V2

USE FXTRAN_ACDC_ABORT_MOD

INTEGER :: STATUS

IF (STATUS /= CUBLAS_STATUS_SUCCESS) THEN
  PRINT *, 'CUBLAS ERROR: STATUS =', STATUS
  CALL FXTRAN_ACDC_ABORT ('FXTRAN_ACDC_GEMM')
END IF

END SUBROUTINE CHECKCUBLAS

SUBROUTINE CHECKCUDA (STATUS)

USE CUDAFOR

USE FXTRAN_ACDC_ABORT_MOD

INTEGER :: STATUS

IF (STATUS /= CUDASUCCESS) THEN
  PRINT *, 'CUDA ERROR:', CUDAGETERRORSTRING (STATUS)
  CALL FXTRAN_ACDC_ABORT ('FXTRAN_ACDC_GEMM')
END IF

END SUBROUTINE CHECKCUDA
#endif

#ifdef USE_OPENMP
SUBROUTINE CHECKROCBLAS (STATUS)

USE HIPFORT
USE HIPFORT_ROCBLAS

USE FXTRAN_ACDC_ABORT_MOD

INTEGER :: STATUS

IF (STATUS /= ROCBLAS_STATUS_SUCCESS) THEN
  PRINT *, 'ROCBLAS ERROR: STATUS =', STATUS
  CALL FXTRAN_ACDC_ABORT ('FXTRAN_ACDC_GEMM')
END IF

END SUBROUTINE CHECKROCBLAS

SUBROUTINE CHECKHIP (STATUS)

USE HIPFORT

USE FXTRAN_ACDC_ABORT_MOD

INTEGER :: STATUS

IF (STATUS /= HIPSUCCESS) THEN
!  PRINT *, 'HIP ERROR:', HIPGETERRORSTRING (STATUS)
  PRINT *, 'HIP ERROR:', STATUS
  CALL FXTRAN_ACDC_ABORT ('FXTRAN_ACDC_GEMM')
END IF

END SUBROUTINE CHECKHIP
#endif

END MODULE

