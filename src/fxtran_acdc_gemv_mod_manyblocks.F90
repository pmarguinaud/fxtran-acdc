MODULE FXTRAN_ACDC_GEMV_MOD_MANYBLOCKS

!
! Copyright 2025 Meteo-France
! All rights reserved
! philippe.marguinaud@meteo.fr
!

IMPLICIT NONE

PRIVATE

PUBLIC :: FXTRAN_ACDC_GEMV_MANYBLOCKS

CONTAINS

SUBROUTINE FXTRAN_ACDC_GEMV_MANYBLOCKS (KIDIA, KFDIA, TRANSA, TRANSB, M, N, K, ALPHA, A, &
                                       & LDA, B, LDB, BETA, C, LDC, LDDONE, LDACC,KGPBLKS,YDOFFSET)

#ifdef USE_OPENACC
#if defined(_OPENACC) && (__NVCOMPILER==1)
USE CUBLAS_V2
USE CUDAFOR
#endif


USE FXTRAN_ACDC_STACK_MOD
USE FXTRAN_ACDC_ABORT_MOD

                                ! VERINTS
INTEGER     :: KIDIA
INTEGER     :: KFDIA
CHARACTER*1 :: TRANSA           ! 'N'
CHARACTER*1 :: TRANSB           ! 'T'
INTEGER     :: M                ! KPROMA
INTEGER     :: N                ! 1
INTEGER     :: K                ! KLEVIN
REAL*8      :: ALPHA            ! 1.0_JPRD
REAL*8      :: A (:, :,:)         ! ZIN
INTEGER     :: LDA              ! KPROMA
REAL*8      :: B (:, :)         ! PINTE
INTEGER     :: LDB              ! KLEVOUT
REAL*8      :: BETA             ! 0.0_JPRB
REAL*8      :: C (:,:)            ! POUTS
INTEGER     :: LDC              ! KPROMA
LOGICAL     :: LDDONE
LOGICAL     :: LDACC
INTEGER                  :: KGPBLKS
TYPE (FXTRAN_ACDC_STACK), OPTIONAL :: YDOFFSET

#if defined(_OPENACC) && (__NVCOMPILER==1)
TYPE (CUBLASHANDLE), SAVE :: YLCBH
LOGICAL, SAVE :: LLCBH_INITIALIZED = .FALSE.
INTEGER (KIND=CUDA_STREAM_KIND), SAVE :: STREAM = 0
#endif

INTEGER :: STRIDEA
INTEGER :: STRIDEB
INTEGER :: STRIDEC
INTEGER :: BATCHCOUNT


INTEGER :: JM, JN, JK, JBLK
CHARACTER*1, SAVE :: CLENV = ''
LOGICAL, SAVE :: LLSIMPLE_DGEMM = .FALSE.

IF (CLENV == '') THEN
  CALL GETENV ('FXTRAN_ACDC_SIMPLE_DGEMM', CLENV)
  LLSIMPLE_DGEMM = CLENV (1:1) == '1' 
  CLENV = '0'
ENDIF

IF (TRANSA /= 'N') CALL FXTRAN_ACDC_ABORT ('FXTRAN_ACDC_GEMV')
IF (TRANSB /= 'T') CALL FXTRAN_ACDC_ABORT ('FXTRAN_ACDC_GEMV')

CALL CHECKCONTIGUOUS2 (A(:,:,1))
CALL CHECKCONTIGUOUS2 (B)
CALL CHECKCONTIGUOUS1 (C(:,1))

IF (LDA /= SIZE (A, 1)) CALL FXTRAN_ACDC_ABORT ('FXTRAN_ACDC_GEMV')
IF (LDB /= SIZE (B, 1)) CALL FXTRAN_ACDC_ABORT ('FXTRAN_ACDC_GEMV')
IF (LDC /= SIZE (C, 1)) CALL FXTRAN_ACDC_ABORT ('FXTRAN_ACDC_GEMV')
IF (KIDIA /= 1) CALL FXTRAN_ACDC_ABORT ('FXTRAN_ACDC_GEMV')
IF (ALPHA /= 1._8) CALL FXTRAN_ACDC_ABORT ('FXTRAN_ACDC_GEMV')
IF (BETA /= 0._8) CALL FXTRAN_ACDC_ABORT ('FXTRAN_ACDC_GEMV')

IF (LLSIMPLE_DGEMM) THEN

  !$ACC PARALLEL LOOP GANG &
  !$ACC&PRESENT (A, B, C) &
  !$ACC&PRIVATE(JBLK) &
  !$ACC&VECTOR_LENGTH (LDA) IF(LDACC) 
  DO JBLK=1,KGPBLKS
  !$ACC LOOP VECTOR&
  !$ACC&PRIVATE(JM,JK)
    DO JM = KIDIA, MERGE(M,KFDIA,JBLK<KGPBLKS)
      C (JM,JBLK) = 0.
      DO JK = 1, K
        C (JM,JBLK) = C (JM,JBLK) + B (LDB , JK) * A (JM, JK, JBLK)
      ENDDO
    ENDDO
  ENDDO

ELSE

  IF (LDACC) THEN
#if defined(_OPENACC) && (__NVCOMPILER==1)

    IF (.NOT. LLCBH_INITIALIZED) THEN
      CALL CHECKCUBLAS (CUBLASCREATE (YLCBH))
      CALL CHECKCUBLAS (CUBLASGETSTREAM (YLCBH, STREAM))
      LLCBH_INITIALIZED = .TRUE.
    ENDIF

    STRIDEA= STRIDE3 (A)
    STRIDEB= 0
    STRIDEC= STRIDE2 (C)
    BATCHCOUNT=KGPBLKS

    !$ACC DATA PRESENT(A,B,C)
    !$ACC HOST_DATA USE_DEVICE(A,B,C)
     CALL CHECKCUBLAS (&
      & CUBLASDGEMMSTRIDEDBATCHED_V2 (YLCBH, CUBLAS_OP_N, CUBLAS_OP_T, M, 1, K, &
      &                        ALPHA, A (1, 1, 1), LDA, STRIDEA, &
      &                               B (LDB, 1),    LDB, STRIDEB, &
      &                        BETA,  C (1, 1), LDC, STRIDEC, &
      &                               BATCHCOUNT))   
    !$ACC END HOST_DATA
    !$ACC END DATA
    CALL CHECKCUDA (CUDASTREAMSYNCHRONIZE (STREAM))

#else
    CALL FXTRAN_ACDC_ABORT('FXTRAN_ACDC_GEMV_MANYBLOCKS')
#endif

  ELSE
    DO JBLK=1,KGPBLKS
      CALL DGEMM ('N','T', M, N, K, ALPHA, A(1,1,JBLK), LDA, B(LDB,1), LDB, BETA, C(1,JBLK), LDC)
    ENDDO
  ENDIF

ENDIF

LDDONE = .TRUE.

#endif

#ifdef USE_OPENMP
!#ifdef __HIP_PLATFORM_AMD__   !!compilation de hip avec amdflang a priori
USE HIPFORT
USE HIPFORT_ROCBLAS
USE ISO_C_BINDING
!#endif

USE FXTRAN_ACDC_STACK_MOD
USE FXTRAN_ACDC_ABORT_MOD

                                ! VERINTS
INTEGER     :: KIDIA
INTEGER     :: KFDIA
CHARACTER*1 :: TRANSA           ! 'N'
CHARACTER*1 :: TRANSB           ! 'T'
INTEGER     :: M                ! KPROMA
INTEGER     :: N                ! 1
INTEGER     :: K                ! KLEVIN
REAL*8      :: ALPHA            ! 1.0_JPRD
REAL*8      :: A (:, :,:)         ! ZIN
INTEGER     :: LDA              ! KPROMA
REAL*8      :: B (:, :)         ! PINTE
INTEGER     :: LDB              ! KLEVOUT
REAL*8      :: BETA             ! 0.0_JPRB
REAL*8      :: C (:,:)            ! POUTS
INTEGER     :: LDC              ! KPROMA
LOGICAL     :: LDDONE
LOGICAL     :: LDACC
INTEGER                  :: KGPBLKS
TYPE (FXTRAN_ACDC_STACK), OPTIONAL :: YDOFFSET

TYPE (C_PTR), SAVE :: YLCBH
LOGICAL, SAVE :: LLCBH_INITIALIZED = .FALSE.
TYPE (C_PTR), SAVE :: STREAM 

INTEGER(C_INT64_T) :: STRIDEA
INTEGER(C_INT64_T) :: STRIDEB
INTEGER(C_INT64_T) :: STRIDEC
INTEGER :: BATCHCOUNT


INTEGER :: JM, JN, JK, JBLK
CHARACTER*1, SAVE :: CLENV = ''
LOGICAL, SAVE :: LLSIMPLE_DGEMM = .FALSE.

IF (CLENV == '') THEN
  CALL GETENV ('FXTRAN_ACDC_SIMPLE_DGEMM', CLENV)
  LLSIMPLE_DGEMM = CLENV (1:1) == '1' 
  CLENV = '0'
ENDIF

IF (TRANSA /= 'N') CALL FXTRAN_ACDC_ABORT ('FXTRAN_ACDC_GEMV')
IF (TRANSB /= 'T') CALL FXTRAN_ACDC_ABORT ('FXTRAN_ACDC_GEMV')

CALL CHECKCONTIGUOUS2 (A(:,:,1))
CALL CHECKCONTIGUOUS2 (B)
CALL CHECKCONTIGUOUS1 (C(:,1))

IF (LDA /= SIZE (A, 1)) CALL FXTRAN_ACDC_ABORT ('FXTRAN_ACDC_GEMV')
IF (LDB /= SIZE (B, 1)) CALL FXTRAN_ACDC_ABORT ('FXTRAN_ACDC_GEMV')
IF (LDC /= SIZE (C, 1)) CALL FXTRAN_ACDC_ABORT ('FXTRAN_ACDC_GEMV')
IF (KIDIA /= 1) CALL FXTRAN_ACDC_ABORT ('FXTRAN_ACDC_GEMV')
IF (ALPHA /= 1._8) CALL FXTRAN_ACDC_ABORT ('FXTRAN_ACDC_GEMV')
IF (BETA /= 0._8) CALL FXTRAN_ACDC_ABORT ('FXTRAN_ACDC_GEMV')

IF (LLSIMPLE_DGEMM) THEN

  !$OMP TARGET DATA MAP(PRESENT:A(1:LDA,1:K,1:KGPBLKS), B(1:LDB,1:K), C(1:LDC,1:KGPBLKS)) IF(LDACC)
  !$OMP TARGET TEAMS DISTRIBUTE PRIVATE(JBLK) THREAD_LIMIT(LDA) IF(LDACC)
  DO JBLK=1,KGPBLKS
  !$OMP PARALLEL DO SIMD PRIVATE(JM,JN) IF(LDACC)
    DO JM = KIDIA, MERGE(M,KFDIA,JBLK<KGPBLKS)
      C (JM,JBLK) = 0.
      DO JK = 1, K
        C (JM,JBLK) = C (JM,JBLK) + B (LDB , JK) * A (JM, JK, JBLK)
      ENDDO
    ENDDO
  ENDDO
  !$OMP END TARGET DATA

ELSE

  IF (LDACC) THEN

!#ifdef __HIP_PLATFORM_AMD__   !!compilation de hip avec amdflang a priori
#ifdef USE_OPENMP

    IF (.NOT. LLCBH_INITIALIZED) THEN
      CALL CHECKROCBLAS (ROCBLAS_CREATE_HANDLE (YLCBH))
      CALL CHECKROCBLAS(ROCBLAS_GET_STREAM(YLCBH,STREAM))     
      LLCBH_INITIALIZED = .TRUE.
    ENDIF

    STRIDEA= STRIDE3 (A)
    STRIDEB= 0
    STRIDEC= STRIDE2 (C)
    BATCHCOUNT=KGPBLKS

    !$OMP TARGET DATA MAP(PRESENT:A(1:LDA,1:K,1:KGPBLKS), B(1:LDB,1:K), C(1:LDC,1:KGPBLKS))
    !$OMP TARGET DATA USE_DEVICE_ADDR (A, B, C)
     CALL CHECKROCBLAS (&
      & ROCBLAS_DGEMM_STRIDED_BATCHED (YLCBH, ROCBLAS_OPERATION_NONE, ROCBLAS_OPERATION_TRANSPOSE, M, 1, K, &
      &                        ALPHA, A (1, 1, 1), LDA, STRIDEA, &
      &                               B (LDB, 1),    LDB, STRIDEB, &
      &                        BETA,  C (1, 1), LDC, STRIDEC, &
      &                               BATCHCOUNT))   
!$OMP END TARGET DATA 
!$OMP END TARGET DATA

    CALL CHECKHIP (HIPSTREAMSYNCHRONIZE (STREAM))

#else
    CALL FXTRAN_ACDC_ABORT('FXTRAN_ACDC_GEMV_MANYBLOCKS')
#endif

  ELSE
    DO JBLK=1,KGPBLKS
      CALL DGEMM ('N','T', M, N, K, ALPHA, A(1,1,JBLK), LDA, B(LDB,1), LDB, BETA, C(1,JBLK), LDC)
    ENDDO
  ENDIF

ENDIF

LDDONE = .TRUE.


#endif

END SUBROUTINE

INTEGER FUNCTION STRIDE3 (P)
REAL*8 :: P (:,:,:)
STRIDE3 = (LOC (P (1, 1, 2)) - LOC (P (1, 1, 1))) / 8
END FUNCTION

INTEGER FUNCTION STRIDE2 (P)
REAL*8 :: P (:,:)
STRIDE2 = (LOC (P (1, 2)) - LOC (P (1, 1))) / 8
END FUNCTION

SUBROUTINE CHECKCONTIGUOUS1 (P)

USE FXTRAN_ACDC_ABORT_MOD

REAL*8 :: P (:)
IF (LOC (P (2)) - LOC (P (1)) /= 8) CALL FXTRAN_ACDC_ABORT ('FXTRAN_ACDC_GEMM')
END SUBROUTINE

SUBROUTINE CHECKCONTIGUOUS2 (P)

USE FXTRAN_ACDC_ABORT_MOD

REAL*8 :: P (:, :)
IF (LOC (P (1, 2)) - LOC (P (1, 1)) /= SIZE (P, 1) * 8) CALL FXTRAN_ACDC_ABORT ('FXTRAN_ACDC_GEMM')
END SUBROUTINE

#if defined(_OPENACC) && (__NVCOMPILER==1)
SUBROUTINE CHECKCUBLAS (STATUS)

USE CUBLAS_V2

USE FXTRAN_ACDC_ABORT_MOD

INTEGER :: STATUS

IF (STATUS /= CUBLAS_STATUS_SUCCESS) THEN
  PRINT *, 'CUBLAS ERROR: STATUS =', STATUS
  CALL FXTRAN_ACDC_ABORT ('FXTRAN_ACDC_GEMM')
END IF

END SUBROUTINE CHECKCUBLAS

SUBROUTINE CHECKCUDA (STATUS)

USE CUDAFOR

USE FXTRAN_ACDC_ABORT_MOD

INTEGER :: STATUS

IF (STATUS /= CUDASUCCESS) THEN
  PRINT *, 'CUDA ERROR:', CUDAGETERRORSTRING (STATUS)
  CALL FXTRAN_ACDC_ABORT ('FXTRAN_ACDC_GEMM')
END IF

END SUBROUTINE CHECKCUDA
#endif

#ifdef USE_OPENMP
SUBROUTINE CHECKROCBLAS (STATUS)

USE HIPFORT
USE HIPFORT_ROCBLAS

USE FXTRAN_ACDC_ABORT_MOD

INTEGER :: STATUS

IF (STATUS /= ROCBLAS_STATUS_SUCCESS) THEN
  PRINT *, 'ROCBLAS ERROR: STATUS =', STATUS
  CALL FXTRAN_ACDC_ABORT ('FXTRAN_ACDC_GEMM')
END IF

END SUBROUTINE CHECKROCBLAS

SUBROUTINE CHECKHIP (STATUS)

USE HIPFORT

USE FXTRAN_ACDC_ABORT_MOD

INTEGER :: STATUS

IF (STATUS /= HIPSUCCESS) THEN
!  PRINT *, 'HIP ERROR:', HIPGETERRORSTRING (STATUS)
  PRINT *, 'HIP ERROR:', STATUS
  CALL FXTRAN_ACDC_ABORT ('FXTRAN_ACDC_GEMM')
END IF

END SUBROUTINE CHECKHIP


#endif


END MODULE
