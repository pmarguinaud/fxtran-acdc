#!/usr/bin/env perl 

=head1 NAME

fxtran-f90

=head1 SYNOPSIS

  $ fxtran-f90 --config fxtran.conf [.. fxtran generation options ..] -- pgf90 [.. PGI options ..] file.F90

=head1 DESCRIPTION

C<fxtran-f90> is compiler wrapper performing the following tasks:

=over 4

=item 

Apply some transformations on user-written source code and generate FORTRAN source code ready 
for GPU accelerators.

=item

Compile the original code and code produced at previous step.

=item 

Link all objects into a single one.

=back

C<fxtran-f90> relies on C<fxtran> for parsing and transforming FORTRAN source code.

=head1 OPTIONS

C<fxtran-f90> accepts all options of C<fxtran-gen>, and the following options:

=over 4

=item --dryrun 

Transform the code, dump the result into files, but does not compile the produced
source code.

=item --debug

Do not remove intermediate files and temporary directories.

=item --package

Package used for generation (defaults to C<Fxtran::Generate>).

=item --method

Force a transformation method; the default is to read the transformation method
from the FORTRAN source code (this should be an ACDC directive).

=item --config

Read options from a config file. Please note that options passed before --config are 
superseded by options from the configuration file. Likewise, options from the configuration
file are overridden by options passed after the configuration file.

=item --user-directory-in

This option takes a directory name as input. If a transformation produces a file and 
this file exists in this directory (provided by C<--user-directory-in>), then the file
from this directory is compiled. This is used for debugging.

=item --user-directory-out

This option takes a directory name where results from transformations are written. This
allows for inspection of generated source code by the user.

=item --prefix

This option takes a directory name where fxtran-acdc libraries and headers are installed. These
libraries are compiled using C<fxtran-boot>.

=item --object-merge-method

Method used to produce a single object file. Can be either 'link' (compile in parallel 
and use the linker to merge the two objects), 'concatenate' (concatenate source
code before compiling), or 'archive' (merge objects into an archive).

=back

Options passed to C<fxtran-f90> must be followed by a double hyphen (C<-->); then come the
compiler name followed by the compiler options and files to be processed.

Note that C<fxtran-f90> will pass fxtran-acdc libraries and includes to the compiler, and will define 
the following macros:

=over 4

=item 

C<FXTRAN_ACDC>

=item 

C<FXTRAN_FILE>

=item 

C<FXTRAN_LINE>

=back

=head1 EXAMPLES

=head2 DIRECTIVE INSTRUMENTED FILE

  SUBROUTINE ACTKE ( YDCST, YDLDDH, YDMDDH, YDML_PHY_MF, KIDIA, KFDIA, KLON, KTDIAT, KTDIAN, KLEV,      &
  & PAPHI, PAPHIF, PAPRS, PAPRSF, PDELP, PR, PT, PU, PV, PQ, PQICONV,  PQLCONV, PLSCPE, PCD, PCH, PGZ0, &
  & PTS, PQS, PQICE, PQLI, PECT, PPRODTH,  PNLAB, PNLABCVP, PKTROV, PKQROV, PKQLROV, PKUROV, PXTROV,    &
  & PXUROV, PNBVNO,  PNEBS, PQCS, PNEBS0, PQCS0, PCOEFN, PFECT, PFECTI, PECT1, PTPRDY, PEDR,  YDDDH)
  
  !$ACDC singlecolumn 
  
  USE MODEL_PHYSICS_MF_MOD , ONLY : MODEL_PHYSICS_MF_TYPE
  ...
  USE DDH_MIX              , ONLY : ADD_FIELD_3D, TYP_DDH, NEW_ADD_FIELD_3D
  
  IMPLICIT NONE
  
  TYPE(TCST)                  ,INTENT(IN)     :: YDCST
  TYPE(TLDDH)                 ,INTENT(IN)     :: YDLDDH
  ...
  INTEGER(KIND=JPIM)          ,INTENT(IN)     :: KLEV 
  REAL(KIND=JPRB)             ,INTENT(IN)     :: PAPHI(KLON,0:KLEV)
  REAL(KIND=JPRB)             ,INTENT(IN)     :: PAPHIF(KLON,KLEV)
  REAL(KIND=JPRB)             ,INTENT(IN)     :: PAPRS(KLON,0:KLEV)

This routine will be processed using the singlecolumn method. C<fxtran-f90> must be invoked as follows:

  $ ls -l actke.F90
  -rw-r--r-- 1 marguina algo 15619  Aug  23 20:14 actke.F90
  $ fxtran-f90 --dryrun -- f90 -c actke.F90
  $ ls -l actke_openacc.F90
  -rw-r--r-- 1 marguina algo 9580  Aug  23 20:17 actke_openacc.F90

The file C<actke_openacc.F90> has been created by the singlecolumn method of the C<Fxtran::Generate> module.


=head2 INTERFACE GENERATION

We use the same file as in the previous example:

  $ fxtran-f90 --method interface --dryrun -- f90 -c actke.F90
  $ ls -l actke.intfb.h
  -rw-r--r-- 1 marguina algo 3984  Aug  23 20:19 actke.intfb.h

F<actke.intfb.h> contains the interface of the routine F<actke.F90>.

We can ask to generate the interface of F<actke_openacc.F90>:

  $ fxtran-f90 --merge-interfaces --method interface --dryrun -- f90 -c actke.F90
  $ ls -l actke.intfb.h
  -rw-r--r-- 1 marguina algo 7278 Aug 23 20:21 actke.intfb.h

F<actke.intfb.h> now contains both the interface of F<actke.F90> and of F<actke_openacc.F90>.

=head1 SEE ALSO

L<fxtran|https://github.com/pmarguinaud/fxtran>, L<fxtran-gen>, L<fxtran-boot>, FORTRAN, XML, L<Fxtran::F90Compiler>

=head1 AUTHOR

philippe.marguinaud@meteo.fr

=head1 COPYRIGHT

Meteo-France 2025

=cut

use warnings;

use Getopt::Long;
use FileHandle;
use Data::Dumper;
use File::Temp;
use File::Basename;
use File::Spec;
use File::Copy;
use File::Path;
use Cwd;

use FindBin qw ($Bin);
use lib "$Bin/../lib";

use strict;

use Fxtran::Common;
use Fxtran::Bt;
use Fxtran::F90Compiler;
use Fxtran::Util;
use Fxtran::PATH;

sub runACDCMethod
{
  my %args = @_;

  my ($opts, $obj, $F90) = @args{qw (opts obj F90)};

  my @f90flags = @{ $args{f90flags} };

  my @I = grep { m/^-I/o } @f90flags;


  for my $ACDC (@{ $args{ACDC} })
    {
      $ACDC =~ s/^(\w+)\s*//o;
      my $method = $1;
     
      my $hopts = 'click'->getOptionList (package => $opts->{package}, method => $method);
     
      my ($ok, @optsfile);
     
      for my $opt (map { m/^(--[\w-]+)=(.*)$/o ? ($1, $2) : ($_) } split (m/\s+/o, $ACDC))
        {
          if ($opt =~ m/^--([\w-]+)$/o)
            {
              my $k = $1;
              $ok = exists ($hopts->{"$k=s"}) 
                 || exists ($hopts->{"$k!"}) 
                 || (($k =~ s/^no//o) && exists ($hopts->{"$k!"})) 
                 || 0;
            }
          push @optsfile, $opt if ($ok);
        }

      my $tmp =  'File::Temp'->newdir (CLEANUP => ! $opts->{debug});

      my @cmd = ("fxtran-gen", $opts->{package}, $method, 
                 'click'->hashToCommandLine (package => $opts->{package}, method => $method, opts => $opts),
                 '--tmp' => "$tmp", @optsfile, @I, $F90);

      &Fxtran::Util::runCommand (cmd => \@cmd, %$opts);
    }

  &Fxtran::F90Compiler::compile (%args);
}

my ($package, $config, $iconfig) = ('generate');

# Look for config

for (my $i = 0; $i < $#ARGV; $i++)
  {
    last if ($ARGV[$i] eq '--');
    next unless ($ARGV[$i] eq '--config');
    $iconfig = $i;
    $config = $ARGV[$i+1];
    last;
  }

if ($config)
  {
    die ("Configution file `$config' was not found") 
      unless (-f $config);
    $config = 'File::Spec'->rel2abs ($config);
    $config = do ("$config");
    if (my $c = $@)
      {
        die ($c);
      }

# Insert config arguments in place of config options

    @ARGV = (@ARGV[0..$iconfig-1], @$config, @ARGV[$iconfig+2..$#ARGV]);
  }

# Look for package

for (my $i = 0; $i < $#ARGV; $i++)
  {
    last if ($ARGV[$i] eq '--');
    next unless ($ARGV[$i] eq '--package');
    $package = $ARGV[$i+1];
    last;
  }

$package = 'Fxtran::' . ucfirst ($package) 
  unless ($package =~ m/::/o);

my %opts = ('object-merge-method' => 'link', package => $package, config => $config);

&Fxtran::Util::loadModule ($package);

my $hopts = 'click'->getOptionList (package => $package);

my @opts_f = qw (dryrun debug);
my @opts_s = qw (package method config user-directory-in user-directory-out prefix object-merge-method);

&GetOptions
(
  (map
  {
    my $key = my $opt = $_; 
    $key =~ s/(?:=s|\!)$//o;
    $opts{$key} = $hopts->{$key};
    ($opt, \$opts{$key})
  }
  keys (%$hopts)),
  (map { ($_, \$opts{$_}) } @opts_f),
  (map { ("$_=s", \$opts{$_}) } @opts_s),
);

for (qw (user-directory-in user-directory-out))
  {
    $opts{$_} = 'File::Spec'->rel2abs ($opts{$_})
     if ($opts{$_});
  }

$opts{package} = 'Fxtran::' . ucfirst ($opts{package}) 
  unless ($opts{package} =~ m/::/o);

if ($opts{help})
  {
    print
     "Usage: " . &basename ($0) . "\n" .
      join ('', map { "  --$_\n" } @opts_f) .
      join ('', map { "  --$_=...\n" } @opts_f) .
     "\n";
    exit (0);
  }

my $f90compiler = shift (@ARGV);

my $c = grep { $_ eq '-c' } @ARGV;


if ($opts{prefix})
  {
    unshift (@ARGV, "-I$opts{prefix}/include");
    push (@ARGV, "-L$opts{prefix}/lib", '-lACDC');
  }

push @ARGV, '-DFXTRAN_ACDC', '-DFXTRAN_FILE=__FILE__', '-DFXTRAN_LINE=__LINE__';

unless ($c)
  {
    exec ($f90compiler, @ARGV) 
      unless ($opts{dryrun});
    exit (0);
  }

# Absolute path for includes

my (@argv, $output);

for (my $i = 0; $i < scalar (@ARGV); $i++)
  {
    if ($ARGV[$i] eq '-o')
      {
        $output = 'File::Spec'->rel2abs ($ARGV[$i+1]);
        $i++;
      }
    elsif ($ARGV[$i] eq '-I')
      {
        push @argv, '-I' . 'File::Spec'->rel2abs ($ARGV[$i+1]);
        $i++;
      }
    elsif ($ARGV[$i] eq '-module')
      {
        push @argv, $ARGV[$i], 'File::Spec'->rel2abs ($ARGV[$i+1]);
        $i++;
      }
    elsif (my ($inc) = ($ARGV[$i] =~ m/^-I(.*)$/o))
      {
        push @argv, '-I' . 'File::Spec'->rel2abs ($inc);
      }
    else
      {
        push @argv, $ARGV[$i];
      }
  }

@ARGV = @argv;

my @F90 = grep { m/\.(?:F90|F)$/io } @ARGV;
my @f90flags = grep { ! m/\.(?:F90|F)$/io } @ARGV;

if ((scalar (@F90) > 1) && ($output))
  {
    die ("Cannot specify -o with -c and multiple files");
  }

my $cwd = &cwd ();

unshift (@f90flags, "-I$cwd");

my $dir = (delete $opts{dir}) || '.'; 
my $tmp = delete $opts{tmp}; $tmp = undef if ($tmp && ($tmp eq '.'));

FILE: for my $F90 (@F90)
  {

    if ($tmp)
      {
        $dir = 'File::Temp'->newdir (CLEANUP => 0);
      }

    chdir ($dir);

    $F90 = 'File::Spec'->rel2abs ($F90, $cwd);

    my $obj = $output;

    unless ($obj)
      {
        ($obj = &basename ($F90)) =~ s/\.(?:F90|F)$/.o/io;
        $obj = 'File::Spec'->rel2abs ($obj, $cwd);
      }

    (-f $F90) or die ("File `$F90' does not exist");

    my @text = do { my $fh = 'FileHandle'->new ("<$F90"); <$fh> };

    my @ACDC;

    if ($opts{method})
      {
        @ACDC = ($opts{method});
      }
    else
      {
        @ACDC = grep { (! m/\{\s*$/o) && (! m/\}\s*$/o) && (! m/\&\s*$/o) && (! m/^(?:BEGIN|END)\s+/o) }
                map { m/^\!\$ACDC (\S.*)$/o ? ($1) : () } @text;
      }

    if (@ACDC)
      {
        &runACDCMethod
        (
          f90compiler => $f90compiler, 
          f90flags => ['-I' . &dirname ($F90), @f90flags],  # Look for includes near current file
          obj => $obj, 
          F90 => $F90, 
          opts => \%opts,
          cwd => $cwd, 
          ACDC => \@ACDC,
        );
      }
    else
      {
        &Fxtran::F90Compiler::run 
        (
          f90compiler => $f90compiler, 
          f90flags    => \@f90flags, 
          obj         => $obj, 
          F90         => [$F90], 
          %opts
        );
      }

    for my $mod (<*.mod>, <*.smod>)
      {
        &move ($mod, "$cwd/$mod");
      }

    chdir ($cwd);

    &rmtree ($dir) if ($tmp && (! $opts{debug}));

  }

