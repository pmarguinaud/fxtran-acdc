MODULE UTIL_SPP_MODEL_MOD

USE spp_gen_mod, ONLY : SPP_MODEL

INTERFACE SAVE
MODULE PROCEDURE SAVE_SPP_MODEL
END INTERFACE

INTERFACE LOAD
MODULE PROCEDURE LOAD_SPP_MODEL
END INTERFACE

INTERFACE COPY
MODULE PROCEDURE COPY_SPP_MODEL
END INTERFACE

INTERFACE HOST
MODULE PROCEDURE HOST_SPP_MODEL
END INTERFACE

     
INTERFACE CRC64
MODULE PROCEDURE CRC64_SPP_MODEL
END INTERFACE

INTERFACE WIPE
MODULE PROCEDURE WIPE_SPP_MODEL
END INTERFACE

INTERFACE SIZE
MODULE PROCEDURE SIZE_SPP_MODEL
END INTERFACE


CONTAINS

SUBROUTINE SAVE_SPP_MODEL (KLUN, YD)
USE UTIL_spp_pert_MOD
IMPLICIT NONE
INTEGER, INTENT (IN) :: KLUN
TYPE (SPP_MODEL), INTENT (IN), TARGET :: YD
INTEGER :: J1
WRITE (KLUN) YD%VERSION
WRITE (KLUN) YD%NMAX
WRITE (KLUN) YD%DEFINED_PERTS
WRITE (KLUN) YD%ACTIVE_PERTS
WRITE (KLUN) YD%NDEF
WRITE (KLUN) YD%NACT
WRITE (KLUN) YD%NRFTOTAL
WRITE (KLUN) YD%NRFTOTAL_RADGRID
WRITE (KLUN) YD%NSEED_OFF
DO J1 = LBOUND (YD%PNDEF, 1), UBOUND (YD%PNDEF, 1)
  CALL SAVE_spp_pert (KLUN, YD%PNDEF (J1))
ENDDO
DO J1 = LBOUND (YD%PN, 1), UBOUND (YD%PN, 1)
  CALL SAVE_spp_pert (KLUN, YD%PN (J1))
ENDDO
WRITE (KLUN) YD%TAU
WRITE (KLUN) YD%XLCOR
WRITE (KLUN) YD%SDEV
WRITE (KLUN) YD%KSEED_OFF
END SUBROUTINE

SUBROUTINE LOAD_SPP_MODEL (KLUN, YD)
USE UTIL_spp_pert_MOD
USE PARKIND1, ONLY : JPRD

IMPLICIT NONE
INTEGER, INTENT (IN) :: KLUN
TYPE (SPP_MODEL), INTENT (OUT), TARGET :: YD
INTEGER :: J1
REAL(KIND=JPRD) :: ZTMP0
READ (KLUN) YD%VERSION
READ (KLUN) YD%NMAX
READ (KLUN) YD%DEFINED_PERTS
READ (KLUN) YD%ACTIVE_PERTS
READ (KLUN) YD%NDEF
READ (KLUN) YD%NACT
READ (KLUN) YD%NRFTOTAL
READ (KLUN) YD%NRFTOTAL_RADGRID
READ (KLUN) YD%NSEED_OFF
DO J1 = LBOUND (YD%PNDEF, 1), UBOUND (YD%PNDEF, 1)
  CALL LOAD_spp_pert (KLUN, YD%PNDEF (J1))
ENDDO
DO J1 = LBOUND (YD%PN, 1), UBOUND (YD%PN, 1)
  CALL LOAD_spp_pert (KLUN, YD%PN (J1))
ENDDO
READ (KLUN) ZTMP0
YD%TAU = ZTMP0
READ (KLUN) ZTMP0
YD%XLCOR = ZTMP0
READ (KLUN) ZTMP0
YD%SDEV = ZTMP0
READ (KLUN) YD%KSEED_OFF
END SUBROUTINE


SUBROUTINE COPY_SPP_MODEL (YD, LDCREATED, LDFIELDAPI)
USE UTIL_spp_pert_MOD
IMPLICIT NONE
TYPE (SPP_MODEL), INTENT (IN), TARGET :: YD
LOGICAL, OPTIONAL, INTENT (IN) :: LDCREATED, LDFIELDAPI
LOGICAL :: LLCREATED
LOGICAL :: LLFIELDAPI
INTEGER :: J1

LLFIELDAPI = .FALSE.
IF (PRESENT (LDFIELDAPI)) THEN
  LLFIELDAPI = LDFIELDAPI
ENDIF
LLCREATED = .FALSE.
IF (PRESENT (LDCREATED)) THEN
  LLCREATED = LDCREATED
ENDIF
IF (.NOT. LLCREATED) THEN
  !$ACC ENTER DATA CREATE (YD)
  !$ACC UPDATE DEVICE (YD)
ENDIF









DO J1 = LBOUND (YD%PNDEF, 1), UBOUND (YD%PNDEF, 1)
  CALL COPY_spp_pert (YD%PNDEF (J1), LDCREATED=.TRUE., LDFIELDAPI=LDFIELDAPI)
ENDDO

DO J1 = LBOUND (YD%PN, 1), UBOUND (YD%PN, 1)
  CALL COPY_spp_pert (YD%PN (J1), LDCREATED=.TRUE., LDFIELDAPI=LDFIELDAPI)
ENDDO





END SUBROUTINE

SUBROUTINE HOST_SPP_MODEL (YD)
USE UTIL_spp_pert_MOD

IMPLICIT NONE
TYPE (SPP_MODEL), TARGET :: YD
INTEGER :: J1









DO J1 = LBOUND (YD%PNDEF, 1), UBOUND (YD%PNDEF, 1)
  CALL HOST_spp_pert (YD%PNDEF (J1))
ENDDO

DO J1 = LBOUND (YD%PN, 1), UBOUND (YD%PN, 1)
  CALL HOST_spp_pert (YD%PN (J1))
ENDDO





END SUBROUTINE

     

SUBROUTINE CRC64_SPP_MODEL (YD, KLUN, CDPATH)
USE UTIL_spp_pert_MOD
USE CRC64_INTRINSIC, ONLY : FCRC64 => CRC64

IMPLICIT NONE
TYPE (SPP_MODEL), TARGET :: YD
INTEGER, INTENT (IN) :: KLUN
CHARACTER(LEN=*), INTENT (IN) :: CDPATH
CHARACTER(LEN=128) :: CLIND
INTEGER :: J1
WRITE (KLUN, '(Z16.16," ",A)') FCRC64 (YD%VERSION), CDPATH//'%VERSION'

WRITE (KLUN, '(Z16.16," ",A)') FCRC64 (YD%NMAX), CDPATH//'%NMAX'

WRITE (KLUN, '(Z16.16," ",A)') FCRC64 (YD%DEFINED_PERTS), CDPATH//'%DEFINED_PERTS'

WRITE (KLUN, '(Z16.16," ",A)') FCRC64 (YD%ACTIVE_PERTS), CDPATH//'%ACTIVE_PERTS'

WRITE (KLUN, '(Z16.16," ",A)') FCRC64 (YD%NDEF), CDPATH//'%NDEF'

WRITE (KLUN, '(Z16.16," ",A)') FCRC64 (YD%NACT), CDPATH//'%NACT'

WRITE (KLUN, '(Z16.16," ",A)') FCRC64 (YD%NRFTOTAL), CDPATH//'%NRFTOTAL'

WRITE (KLUN, '(Z16.16," ",A)') FCRC64 (YD%NRFTOTAL_RADGRID), CDPATH//'%NRFTOTAL_RADGRID'

WRITE (KLUN, '(Z16.16," ",A)') FCRC64 (YD%NSEED_OFF), CDPATH//'%NSEED_OFF'

DO J1 = LBOUND (YD%PNDEF, 1), UBOUND (YD%PNDEF, 1)
  WRITE (CLIND, '("(",I0,")")') J1
  CALL CRC64_spp_pert (YD%PNDEF (J1), KLUN, CDPATH//'%PNDEF'//TRIM(CLIND))
ENDDO

DO J1 = LBOUND (YD%PN, 1), UBOUND (YD%PN, 1)
  WRITE (CLIND, '("(",I0,")")') J1
  CALL CRC64_spp_pert (YD%PN (J1), KLUN, CDPATH//'%PN'//TRIM(CLIND))
ENDDO

WRITE (KLUN, '(Z16.16," ",A)') FCRC64 (YD%TAU), CDPATH//'%TAU'

WRITE (KLUN, '(Z16.16," ",A)') FCRC64 (YD%XLCOR), CDPATH//'%XLCOR'

WRITE (KLUN, '(Z16.16," ",A)') FCRC64 (YD%SDEV), CDPATH//'%SDEV'

WRITE (KLUN, '(Z16.16," ",A)') FCRC64 (YD%KSEED_OFF), CDPATH//'%KSEED_OFF'

END SUBROUTINE

SUBROUTINE WIPE_SPP_MODEL (YD, LDDELETED, LDFIELDAPI)
USE UTIL_spp_pert_MOD
IMPLICIT NONE
TYPE (SPP_MODEL), INTENT (IN), TARGET :: YD
LOGICAL, OPTIONAL, INTENT (IN) :: LDDELETED, LDFIELDAPI
LOGICAL :: LLDELETED
LOGICAL :: LLFIELDAPI
INTEGER :: J1

LLFIELDAPI = .FALSE.
IF (PRESENT (LDFIELDAPI)) THEN
  LLFIELDAPI = LDFIELDAPI
ENDIF









DO J1 = LBOUND (YD%PNDEF, 1), UBOUND (YD%PNDEF, 1)
  CALL WIPE_spp_pert (YD%PNDEF (J1), LDDELETED=.TRUE., LDFIELDAPI=LDFIELDAPI)
ENDDO

DO J1 = LBOUND (YD%PN, 1), UBOUND (YD%PN, 1)
  CALL WIPE_spp_pert (YD%PN (J1), LDDELETED=.TRUE., LDFIELDAPI=LDFIELDAPI)
ENDDO





LLDELETED = .FALSE.
IF (PRESENT (LDDELETED)) THEN
  LLDELETED = LDDELETED
ENDIF
IF (.NOT. LLDELETED) THEN
  !$ACC EXIT DATA DELETE (YD)
ENDIF
END SUBROUTINE

INTEGER*8 FUNCTION SIZE_SPP_MODEL (YD, CDPATH, LDPRINT) RESULT (KSIZE)
USE UTIL_spp_pert_MOD
IMPLICIT NONE
TYPE (SPP_MODEL),     INTENT (IN), TARGET :: YD
CHARACTER(LEN=*), INTENT (IN), OPTIONAL :: CDPATH
LOGICAL,          INTENT (IN), OPTIONAL :: LDPRINT
INTEGER*8 :: ISIZE, JSIZE
LOGICAL :: LLPRINT
CHARACTER(LEN=128) :: CLPATH
INTEGER :: J1

LLPRINT = .FALSE.
IF (PRESENT (LDPRINT)) THEN
  LLPRINT = LDPRINT
ENDIF
CLPATH=''
IF (PRESENT (CDPATH)) THEN
  CLPATH = CDPATH
ENDIF
KSIZE = 0
ISIZE = KIND (YD%VERSION) * LEN (YD%VERSION)
IF (LLPRINT) THEN
  WRITE (*, '(I10," ")', ADVANCE='NO') ISIZE
  WRITE (*, *) TRIM (CLPATH)//'%VERSION'
ENDIF
KSIZE = KSIZE + ISIZE
ISIZE = KIND (YD%NMAX)
IF (LLPRINT) THEN
  WRITE (*, '(I10," ")', ADVANCE='NO') ISIZE
  WRITE (*, *) TRIM (CLPATH)//'%NMAX'
ENDIF
KSIZE = KSIZE + ISIZE
ISIZE = KIND (YD%DEFINED_PERTS) * SIZE (YD%DEFINED_PERTS) * LEN (YD%DEFINED_PERTS)
IF (LLPRINT) THEN
  WRITE (*, '(I10," ")', ADVANCE='NO') ISIZE
  WRITE (*, *) TRIM (CLPATH)//'%DEFINED_PERTS'
ENDIF
KSIZE = KSIZE + ISIZE
ISIZE = KIND (YD%ACTIVE_PERTS) * SIZE (YD%ACTIVE_PERTS) * LEN (YD%ACTIVE_PERTS)
IF (LLPRINT) THEN
  WRITE (*, '(I10," ")', ADVANCE='NO') ISIZE
  WRITE (*, *) TRIM (CLPATH)//'%ACTIVE_PERTS'
ENDIF
KSIZE = KSIZE + ISIZE
ISIZE = KIND (YD%NDEF)
IF (LLPRINT) THEN
  WRITE (*, '(I10," ")', ADVANCE='NO') ISIZE
  WRITE (*, *) TRIM (CLPATH)//'%NDEF'
ENDIF
KSIZE = KSIZE + ISIZE
ISIZE = KIND (YD%NACT)
IF (LLPRINT) THEN
  WRITE (*, '(I10," ")', ADVANCE='NO') ISIZE
  WRITE (*, *) TRIM (CLPATH)//'%NACT'
ENDIF
KSIZE = KSIZE + ISIZE
ISIZE = KIND (YD%NRFTOTAL)
IF (LLPRINT) THEN
  WRITE (*, '(I10," ")', ADVANCE='NO') ISIZE
  WRITE (*, *) TRIM (CLPATH)//'%NRFTOTAL'
ENDIF
KSIZE = KSIZE + ISIZE
ISIZE = KIND (YD%NRFTOTAL_RADGRID)
IF (LLPRINT) THEN
  WRITE (*, '(I10," ")', ADVANCE='NO') ISIZE
  WRITE (*, *) TRIM (CLPATH)//'%NRFTOTAL_RADGRID'
ENDIF
KSIZE = KSIZE + ISIZE
ISIZE = KIND (YD%NSEED_OFF) * SIZE (YD%NSEED_OFF)
IF (LLPRINT) THEN
  WRITE (*, '(I10," ")', ADVANCE='NO') ISIZE
  WRITE (*, *) TRIM (CLPATH)//'%NSEED_OFF'
ENDIF
KSIZE = KSIZE + ISIZE
JSIZE = 0
DO J1 = LBOUND (YD%PNDEF, 1), UBOUND (YD%PNDEF, 1)
  ISIZE = SIZE_spp_pert (YD%PNDEF (J1), CLPATH//'%PNDEF', .FALSE.)
  JSIZE = JSIZE + ISIZE
  KSIZE = KSIZE + ISIZE
ENDDO
IF (LLPRINT) THEN
  WRITE (*, '(I10," ")', ADVANCE='NO') JSIZE
  WRITE (*, *) TRIM (CLPATH)//'%PNDEF'
ENDIF
JSIZE = 0
DO J1 = LBOUND (YD%PN, 1), UBOUND (YD%PN, 1)
  ISIZE = SIZE_spp_pert (YD%PN (J1), CLPATH//'%PN', .FALSE.)
  JSIZE = JSIZE + ISIZE
  KSIZE = KSIZE + ISIZE
ENDDO
IF (LLPRINT) THEN
  WRITE (*, '(I10," ")', ADVANCE='NO') JSIZE
  WRITE (*, *) TRIM (CLPATH)//'%PN'
ENDIF
ISIZE = KIND (YD%TAU)
IF (LLPRINT) THEN
  WRITE (*, '(I10," ")', ADVANCE='NO') ISIZE
  WRITE (*, *) TRIM (CLPATH)//'%TAU'
ENDIF
KSIZE = KSIZE + ISIZE
ISIZE = KIND (YD%XLCOR)
IF (LLPRINT) THEN
  WRITE (*, '(I10," ")', ADVANCE='NO') ISIZE
  WRITE (*, *) TRIM (CLPATH)//'%XLCOR'
ENDIF
KSIZE = KSIZE + ISIZE
ISIZE = KIND (YD%SDEV)
IF (LLPRINT) THEN
  WRITE (*, '(I10," ")', ADVANCE='NO') ISIZE
  WRITE (*, *) TRIM (CLPATH)//'%SDEV'
ENDIF
KSIZE = KSIZE + ISIZE
ISIZE = KIND (YD%KSEED_OFF)
IF (LLPRINT) THEN
  WRITE (*, '(I10," ")', ADVANCE='NO') ISIZE
  WRITE (*, *) TRIM (CLPATH)//'%KSEED_OFF'
ENDIF
KSIZE = KSIZE + ISIZE
END FUNCTION

END MODULE
