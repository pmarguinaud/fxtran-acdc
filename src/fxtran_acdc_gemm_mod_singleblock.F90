MODULE FXTRAN_ACDC_GEMM_MOD_SINGLEBLOCK

!
! Copyright 2025 Meteo-France
! All rights reserved
! philippe.marguinaud@meteo.fr
!

IMPLICIT NONE

PRIVATE

PUBLIC :: FXTRAN_ACDC_GEMM_SINGLEBLOCK

CONTAINS

SUBROUTINE FXTRAN_ACDC_GEMM_SINGLEBLOCK (KIDIA, KFDIA, TRANSA, TRANSB, M, N, K, ALPHA, A, &
                                       & LDA, B, LDB, BETA, C, LDC, LDDONE, LDACC )
#ifdef USE_OPENACC
#ifdef _CUDA
USE CUBLAS
#endif

USE FXTRAN_ACDC_ABORT_MOD

                                ! VERINT
INTEGER     :: KIDIA
INTEGER     :: KFDIA
CHARACTER*1 :: TRANSA           ! 'N'
CHARACTER*1 :: TRANSB           ! 'T'
INTEGER     :: M                ! KPROMA
INTEGER     :: N                ! KLEVOUT-1  if verder/verint, 1 if verints  
INTEGER     :: K                ! KLEVIN
REAL*8      :: ALPHA            ! 1.0_JPRD
REAL*8      :: A (LDA, *)       ! ZIN
INTEGER     :: LDA              ! KPROMA
REAL*8      :: B (LDB, *)       ! PINTE
INTEGER     :: LDB              ! KLEVOUT
REAL*8      :: BETA             ! 0.0_JPRB
REAL*8      :: C (LDC, *)       ! ZOUT
INTEGER     :: LDC              ! KPROMA
LOGICAL     :: LDDONE
LOGICAL     :: LDACC

INTEGER :: JM, JN, JK
CHARACTER*1, SAVE :: CLENV = ''
LOGICAL, SAVE :: LLSIMPLE_DGEMM = .FALSE.

IF (CLENV == '') THEN
  CALL GETENV ('FXTRAN_ACDC_SIMPLE_DGEMM', CLENV)
  LLSIMPLE_DGEMM = CLENV (1:1) == '1' 
  CLENV = '0'
ENDIF

IF (TRANSA /= 'N') CALL FXTRAN_ACDC_ABORT ('FXTRAN_ACDC_GEMM')
IF (TRANSB /= 'T') CALL FXTRAN_ACDC_ABORT ('FXTRAN_ACDC_GEMM')
IF (KIDIA /= 1) CALL FXTRAN_ACDC_ABORT ('FXTRAN_ACDC_GEMM')

IF (LLSIMPLE_DGEMM) THEN

  !$ACC PARALLEL LOOP GANG VECTOR &
  !$ACC&PRESENT (A, B, C) &
  !$ACC&PRIVATE (JK, JN, JM) IF(LDACC)

  DO JM = KIDIA, KFDIA
    DO JN = 1, N
      C (JM, JN) = 0.
    ENDDO
    DO JK = 1, K
      DO JN = 1, N
        C (JM, JN) = C (JM, JN) + B (JN, JK) * A (JM, JK)
      ENDDO
    ENDDO
  ENDDO

ELSE

#ifdef _CUDA
  IF (LDACC) THEN
#ifdef USE_OPENACC
 
    !$ACC DATA PRESENT(A,B,C)
    !$ACC HOST_DATA USE_DEVICE(A,B,C)
    CALL CUBLASDGEMM ('N','T', M, N, K, ALPHA, A, LDA, B, LDB, BETA, C, LDC)
    !$ACC END HOST_DATA
    !$ACC END DATA
    !$ACC WAIT
#endif

#ifdef USE_OPENMP
!$OMP TARGET DATA USE_DEVICE_ADDR (A, B, C)
#endif

    CALL CUBLASDGEMM ('N','T', M, N, K, ALPHA, A, LDA, B, LDB, BETA, C, LDC)

#ifdef USE_OPENMP
!$OMP END TARGET DATA 
#endif
  
  ELSE
    CALL DGEMM ('N','T', M, N, K, ALPHA, A, LDA, B, LDB, BETA, C, LDC)
  ENDIF
#else
  CALL DGEMM ('N','T', M, N, K, ALPHA, A, LDA, B, LDB, BETA, C, LDC)
#endif
ENDIF

LDDONE = .TRUE.
#endif


#ifdef USE_OPENMP
!#ifdef __HIP_PLATFORM_AMD__   !!compilation de hip avec amdflang a priori
USE HIPFORT
USE HIPFORT_ROCBLAS
USE ISO_C_BINDING
!#endif

USE FXTRAN_ACDC_ABORT_MOD

                                ! VERINT
INTEGER     :: KIDIA
INTEGER     :: KFDIA
CHARACTER*1 :: TRANSA           ! 'N'
CHARACTER*1 :: TRANSB           ! 'T'
INTEGER     :: M                ! KPROMA
INTEGER     :: N                ! KLEVOUT-1  if verder/verint, 1 if verints  
INTEGER     :: K                ! KLEVIN
REAL*8      :: ALPHA            ! 1.0_JPRD
REAL*8      :: A (LDA, *)       ! ZIN
INTEGER     :: LDA              ! KPROMA
REAL*8      :: B (LDB, *)       ! PINTE
INTEGER     :: LDB              ! KLEVOUT
REAL*8      :: BETA             ! 0.0_JPRB
REAL*8      :: C (LDC, *)       ! ZOUT
INTEGER     :: LDC              ! KPROMA
LOGICAL     :: LDDONE
LOGICAL     :: LDACC

TYPE(C_PTR), SAVE :: YLCBH
LOGICAL, SAVE :: LLCBH_INITIALIZED = .FALSE.
TYPE(C_PTR), SAVE :: STREAM 

INTEGER :: JM, JN, JK
CHARACTER*1, SAVE :: CLENV = ''
LOGICAL, SAVE :: LLSIMPLE_DGEMM = .FALSE.

IF (CLENV == '') THEN
  CALL GETENV ('FXTRAN_ACDC_SIMPLE_DGEMM', CLENV)
  LLSIMPLE_DGEMM = CLENV (1:1) == '1' 
  CLENV = '0'
ENDIF

IF (TRANSA /= 'N') CALL FXTRAN_ACDC_ABORT ('FXTRAN_ACDC_GEMM')
IF (TRANSB /= 'T') CALL FXTRAN_ACDC_ABORT ('FXTRAN_ACDC_GEMM')
IF (KIDIA /= 1) CALL FXTRAN_ACDC_ABORT ('FXTRAN_ACDC_GEMM')

IF (.NOT. LLCBH_INITIALIZED) THEN
  CALL CHECKROCBLAS (ROCBLAS_CREATE_HANDLE (YLCBH))
  CALL CHECKROCBLAS(ROCBLAS_GET_STREAM(YLCBH,STREAM))
  LLCBH_INITIALIZED = .TRUE.
ENDIF
write (0,*) "AFFICHAGE LLSIMPLE_DGEMM",LLSIMPLE_DGEMM
IF (LLSIMPLE_DGEMM) THEN
  write (0,*) "AFFICHAGE passage dans simple_dgemm"
!!!!!!!!!!!!  !$OMP TARGET TEAMS DISTRIBUTE PARALLEL DO SIMD PRIVATE(JK,JN) IF(LDACC) 
!!!!!!!!!!!  !$omp target teams if(ldacc)
!!!!!!!!!!!  DO JM = KIDIA, KFDIA
!!!!!!!!!!!    DO JN = 1, N
!!!!!!!!!!!      write(0,*) "jn jm",jn,jm
!!!!!!!!!!!      C (JM, JN) = 0.
!!!!!!!!!!!    ENDDO
!!!!!!!!!!!    DO JK = 1, K
!!!!!!!!!!!      DO JN = 1, N
!!!!!!!!!!!        C (JM, JN) = C (JM, JN) + B (JN, JK) * A (JM, JK)
!!!!!!!!!!!      ENDDO
!!!!!!!!!!!    ENDDO
!!!!!!!!!!!  ENDDO
!!!!!!!!!!!  !$OMP END TARGET TEAMS
!!!!!!!!!!!!  !$OMP END TARGET TEAMS DISTRIBUTE PARALLEL DO SIMD
ELSE

!!!!!!ifdef cuda
#ifndef UNDEF
  IF (LDACC) THEN
#ifdef USE_OPENMP
!$OMP TARGET DATA USE_DEVICE_ADDR (A, B, C)

    CALL CHECKROCBLAS( ROCBLAS_DGEMM (YLCBH,ROCBLAS_OPERATION_NONE,ROCBLAS_OPERATION_TRANSPOSE, M, N, K, ALPHA, A(1,1), LDA, B(1,1), LDB, BETA, C(1,1), LDC))

!$OMP END TARGET DATA 
    CALL CHECKHIP (HIPSTREAMSYNCHRONIZE (STREAM))
    CALL CHECKHIP (HIPDEVICESYNCHRONIZE ())
#else
    CALL FXTRAN_ACDC_ABORT ('FXTRAN_ACDC_GEMM')
#endif
 
  ELSE
    CALL DGEMM ('N','T', M, N, K, ALPHA, A, LDA, B, LDB, BETA, C, LDC)
  ENDIF
#else
  CALL DGEMM ('N','T', M, N, K, ALPHA, A, LDA, B, LDB, BETA, C, LDC)
#endif
ENDIF

LDDONE = .TRUE.



#endif
END SUBROUTINE FXTRAN_ACDC_GEMM_SINGLEBLOCK


#ifdef USE_OPENMP
SUBROUTINE CHECKROCBLAS (STATUS)

USE HIPFORT
USE HIPFORT_ROCBLAS

USE FXTRAN_ACDC_ABORT_MOD

INTEGER :: STATUS

IF (STATUS /= ROCBLAS_STATUS_SUCCESS) THEN
  PRINT *, 'ROCBLAS ERROR: STATUS =', STATUS
  CALL FXTRAN_ACDC_ABORT ('FXTRAN_ACDC_GEMM')
END IF

END SUBROUTINE CHECKROCBLAS

SUBROUTINE CHECKHIP (STATUS)

USE HIPFORT

USE FXTRAN_ACDC_ABORT_MOD

INTEGER :: STATUS

IF (STATUS /= HIPSUCCESS) THEN
!  PRINT *, 'HIP ERROR:', HIPGETERRORSTRING (STATUS)
  CALL FXTRAN_ACDC_ABORT ('FXTRAN_ACDC_GEMM')
END IF

END SUBROUTINE CHECKHIP
#endif

END MODULE
